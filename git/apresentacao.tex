\documentclass[brazil]{beamer}
\usepackage{beamerthemesplit}
\usepackage[brazilian]{babel}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{color}
\usepackage{xcolor}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{fancybox}
\usepackage{ulem}
\usepackage{listings}
\usetheme{JuanLesPins}

\title{Curso de Introdução ao Git}
\author{USPGameDev}

\begin{document}

\frame{\titlepage}

%-------------------------------------
\section{1. Introdução}
%-------------------------------------

\frame{\begin{center}
\Huge Introdução
\end{center}}

\frame{
  \frametitle{O que é Controle de Versão?}
  Softwares de controle de versão é um sistema que grava todas as modificações em um conjunto de arquivos, criando um 
  histórico deles, criando um ambiente onde o usuário possa recriar versões antigas dos arquivos.
  \\
  Eles são separados em 3 conjuntos:
  \begin{itemize}
    \item Controle de versão local. (Ex: rcs)
    \item Controle de versão centralizado. (Ex: SVN, CVS)
    \item Controle de versão distribuído. (Ex: Git, Mercurial)
  \end{itemize}
}

%-------------------------------------
\subsection{Fundamentos}
%-------------------------------------

\frame{\begin{center}
\Huge Fundamentos
\end{center}}

\frame{
  \frametitle{Snapshots, não diferenças}
  O Git, diferente de outros controles de versões que salvam os arquivos e as modificações entre os commits, 
  o Git \, a cada commit, o estado atual de cada arquivo.
}

\frame{
  \frametitle{Trabalho Local}
  Quase todo trabalho do Git é local. Isso significa que ele não precisa de comunicação constante com algum servidor
  remoto, como é normal em outros CVs. Essa liberdade garante que os usuários não fiquem dependentes de internet ou 
  intranet para trabalhar.
}

\frame{
  \frametitle{Integridade}
  Todo arquivo que está sob os cuidados do Git recebe um checksum ( soma de verificação ). Olhando para esse checksum,
  o Git sabe se algum arquivo ou diretório foi modificado, tornando impossível modificações obscuras.
}

\frame{
  \frametitle{Adição de dados (geralmente...)}
  Quase todas as ações do Git tem como finalidade adicionar dados na database do projeto. Depois que algo foi 
  incorporado em um repositório, é quase impossível tirá-lo de lá.
}

\frame{
  \frametitle{3 Estados}
  Todo e qualquer arquivos que está no Git tem 3 possíveis estados:
  \begin{itemize}
    \item Committed - Significa que as modanças feitas no arquivo estão salvas na database do Git.
    \item Modificado - Significa que o arquivo foi modificado.
    \item Staged - Significa que as mudanças atuais no arquivos seram inclusas no próximo commit.
  \end{itemize}
}

\frame{
  \frametitle{3 Estados}
  %Enfiar imagem aqui.
  Esses 3 estados fazem com que um repositório local do Git seja separado em 3 seções:
  \begin{itemize}
    \item Git directory - Onde todos os arquivos vitais e a database do Git estão.
    \item Working directory - É uma instância de uma versão do seu projeto.
    \item Staging area - Um arquivo que contêm todas as modificações que entrarão no próximo commit.
  \end{itemize}
}

\frame{
  \frametitle{3 Estados}
  O processo de trabalho com o Git pode ser resumido a:
  \begin{enumerate}
    \item Você modifica os arquivos no seu working directory.
    \item Você adiciona as modificações na staging area.
    \item Você commita, aicionando permanentemente as modificações no seu Git directory. 
  \end{enumerate}
}

%-------------------------------------
\subsection{Instalação e Configuração}
%-------------------------------------

\frame{
  \frametitle{Instalação}
  Para instalar o Git, vamos seguir o tutorial do GitHub =D
}

\begin{frame}[fragile]
  \frametitle{Configuração}
  O Git permite uma variedade de configurações. Podemos modificá-las usando o comando:
  \begin{block}{}
    \verb#$ git config#
  \end{block}
  \pause
  Duas configurações que temos que modificar depois de instalar o Git são:
  \begin{block}{}
      \verb#$ git config --global user.name "José da Silva"# \\
      \verb#$ git config --global user.email josé@silva.com.br#
  \end{block}
  Temos que mudar essas configurações pois o Git usam elas para gerar as mensagens de commit.
\end{frame}

%-------------------------------------
\section{Git 101}
%-------------------------------------

%-------------------------------------
\subsection{Repositórios}
%-------------------------------------

\begin{frame}[fragile]
  \frametitle{Iniciando um Repositório}
  Podemos pegar um projeto que usa o Git de duas maneiras distintas:
  \begin{itemize}
    \item Portando um projeto existente para o Git, ou
    \item Clonando um projeto que já usa o Git.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Iniciando um Repositório}
  Para iniciar o Git num projeto já existente basta ir na pasta raiz do projeto e usar o comando:
  \begin{block}{}
    \verb#$ git init#
  \end{block}
  \pause
  Para clonar um projeto que já usa o Git usamos o comando:
  \begin{block}{}
    \verb#$ git clone <url-do-repositorio> <nome-da-pasta>#
  \end{block}
  Esse comando cria uma pasta com o nome do projeto no local em que foi chamado. Podemos
  passar um nome para a pasta que vai seer criada.
\end{frame}

%-------------------------------------
\subsection{Gravando Mudanças}
%-------------------------------------

\begin{frame}[fragile]
  \frametitle{Tracked e Untracked}
  Agora que temos um repositório funcionando, vamos entender como o Git grava as mudanças. \\
  \pause
  Lembram que todo arquivo no Git tinha 3 estados? \\
  \pause
  Podemos adicionar mais dois estados gerais, \textbf{Tracked} e \textbf{Untracked}. \\
  \pause
  Os arquivos \textbf{Tracked} estão na database do Git, e eles podem estar em qualquer dos 3 estados citados
  anteriormente. \\
  \pause
  Os \textbf{Untracked} são os arquivos que não estão na database do Git, ou seja, o Git não grava as mudanças
  feitas neles.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Tracked e Untracked}
  %Imagem tracked untracked%
\end{frame}

\begin{frame}[fragile]
  \frametitle{Git status}
  Mas como sabemos em qual estado estão os arquivos? \\
  \pause
  Podemos usar o comando status do Git, que tem essa saída:
  \begin{block}{}
    \begin{verbatim}
      $ git status
      # On branch master
      # Changes to be committed:
      #   (use "git reset HEAD <file>..." to unstage)
      #
      #   new file:   README
      #
    \end{verbatim}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Mais git status}
  Agora vamos analisar a saída do comando status...
  \begin{block}{}
    \begin{verbatim}
      $ git status
      # On branch master
      # Changes to be committed:
      #   (use "git reset HEAD <file>..." 
              to unstage)
      #
      #   new file:   README
      #
      # Changed but not updated:
      #   (use "git add <file>..." 
              to update what will be committed)
      #
      #   modified:   benchmarks.rb
    \end{verbatim}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Git add}
  O comando git add tem duas principais funcionalidades:
  \begin{itemize}
    \item Adicionar um novo arquivo na database do Git. O arquivo passa de Untracked para Tracked.
    \item Adicionar uma nova versão de um Arquivo Tracked na database. O arquivo passa de modified para staged.
  \end{itemize}
  A sintaxe é simples:
  \begin{block}{}
    \verb#$ git add <nome-do-arquivo>#
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Git rm}
  Assim como podemos adicionar arquivos na database, podemos removê-los. \\
  \pause
  O comando rm do Git remove os arquivos tanto do workdirectory como da database. \\
  \pause
  Temos que tomar cuidado ao deletar um arquivo sem o git rm.
\end{frame}

\begin{frame}[fragile]
  \frametitle{.gitignore}
  Nem sempre é bom que o Git veja todos os arquivos dentro de um projeto. \\
  \pause
  Imagine se toda vez que o comando status lista a saída, temos vários arquivos de compilação lá? \\
  \pause
  Podemos colocar expressões regulares num arquivo chamando \textbf{.gitignore}. \\
  \pause
  Todo arquivo que case com qualquer expressão do \textbf{.gitignore} será ignorado pelo Git. \\
  \pause
  O \textbf{.gitignore} se aplica na pasta que ele se encontra, e em todas abaixo dele. 
\end{frame}

\begin{frame}[fragile]
  \frametitle{Commits}
  Certo. Agora que sabemos como adicionar as mudanças para a area staged. \\
  Mas como passamos essas modificações para a database? \\
  \pause
  Usamos os commits para levar essas modificações até a database. \\
  Para commitar suas mudanças, usamos o comando:
  \begin{block}{}
    \verb#$ git commit#
  \end{block}
  Esse comando abre uma tela de edição onde escrevemos a mensagem de commit. 
\end{frame}

\begin{frame}[fragile]
  \frametitle{Boas práticas de commit}
  Ao commitar, é bom seguir algumas práticas:
  \begin{itemize}
    \item Faça commits pequenos. Isso cria um histórico mais rico.
    \item Crie mensagens que expressem seu commit. Isso ajuda a identificar as mudanças.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Commits}
  O commit leva consigo algumas informações:
  \begin{itemize}
    \item As modificações que foram introduzidas nesse commit.
    \item O nome e o e-mail de que fez o commit.
    \item Um HASH que identifica o commit de maneira unica.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Movendo arquivos}
  Para mover arquivos dentro de um repositorio Git, usamos o comando: \\
  \begin{block}{}
    \verb#$ git mv#
  \end{block}
  \pause
  Se movemos um arquivo usando só o \verb#mv#, o Git percebe que o arquivo foi movido mas não
  adiciona a movimentação automaticamente na staging area.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Git log}
  Para acessar o historico de commits usamos o comando:
  \begin{block}{}
    \verb#$ git log#
  \end{block}
  \pause
  O comando devolve uma lista que mostra todos os commits desde o começo do repositorio. \\
  Cada elemento da lista contêm as informações dos commits ( as mesmas informações que os commits levam 
  consigo).
\end{frame}

%-------------------------------------
\subsection{Desfazendo coisas}
%-------------------------------------

\begin{frame}[fragile]
  \frametitle{--amend}
  O comando commit aceita a opção --amend, que possibilita a edição do commit que acabou de ser feito. \\
  Podemos colocar mais arquivos no commit ou mudar a mensagme do mesmo. \\
  A sintaxe é:
  \begin{block}{}
    \verb#$ git commit --amend#
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{git reset HEAD}
  Para retirar arquivos da area staged, usamos o comando:
  \begin{block}{}
    \verb#$ git reset HEAD <arquivo>#
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{git checkout --}
  Para reverter as modificações feitas em um arquivo que ainda não foi adicionado a database do Git,
  usamos o comando:
  \begin{block}{}
    \verb#$ git checkout -- <arquivo>#
  \end{block}
\end{frame}

%-------------------------------------
\subsection{Repositórios Remotos}
%-------------------------------------

\begin{frame}[fragile]
  \frametitle{Remotos}
  Repositórios remotos são versões do seu repositório local que ficam ou na internet ou em alguma máquina 
  na rede. \\
  \pause
  O seu repositório local reconhece os remotos que ele conhece por aliases. Podemos ver esses aliases
  usando o comando:
  \begin{block}{}
    \verb#$ git remote -v#
  \end{block}
  \pause
  Quando clonamos um repositório, o Git cria um alias chamado origin que faz referência a url "clonada".
\end{frame}

\begin{frame}[fragile]
  \frametitle{Adicionar, Remover e Renomear}
  Para adicionar um novo remote:
  \begin{block}{}
    \verb#$ git remote add <alias> <url>#
  \end{block}
  \pause
  Para remover um remote:
  \begin{block}{}
    \verb#$ git remote rm <alias>#
  \end{block}
  \pause
  Para renomear um remote:
  \begin{block}{}
    \verb#$ git remote rename <alias-velho> <alias-novo>#
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Pushando}
  Para pushar para um remote, usamos o comando:
  \begin{block}{}
    \verb#$ git push <remote-alias> <nome-da-branch>#
  \end{block}
\end{frame}

%-------------------------------------
\section{Branchs}
%-------------------------------------

\begin{frame}[fragile]
  \frametitle{O que são branchs}
  Branchs são separações no fluxo de commits de um repositório. \\
  \pause
  Usamos elas para trabalhar em várias partes do projeto sem influenciar no fluxo principal do mesmo. \\
\end{frame}

\begin{frame}[fragile]
  \frametitle{Criando Branchs}
  Quando criamos uma branch, ela usa o commit atual da branch atual como base por default. \\
  Usamos 2 comandos para criar uma branch:
  \begin{block}{}
    \verb#$ git checkout -b <nome-da-branch># ou \\
    \verb#$ git branch <nome-da-branch>#
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Listando, mudando e deletando de branchs}
  Podemos listar as branchs atuais usando o comando:
  \begin{block}{}
    \verb#$ git branch#
  \end{block}
  A branch que estiver marcada com um * é a branch atual. \\
  \pause
  Para mudar de branchs usamos o comando:
  \begin{block}{}
    \verb#$ git checkout <nome-da-branch>#
  \end{block}
  \pause
  Para deletar uma branch, o comando é:
  \begin{block}{}
    \verb#$ git branch -d <nome-da-branch>#
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Mandando branchs para o remoto}
  Para mandar uma branch para um repositório remoto, o comando push é usado:
  \begin{block}{}
    \verb#$ git push -u <remote> <branch>#
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Merge}
  Para passar as mudanças de uma branch para outra, usamos o comando:
  \begin{block}{}
    \verb#$ git merge <nome-da-branch>#
  \end{block}
  É na branch em que esse comando é rodado que a junção das modificações ficara.
\end{frame}

\end{document}
